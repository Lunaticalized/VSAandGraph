% % Title and author(s)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{CS 703 Project Proposal}
\author{Xiating Ouyang}
\date{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% % The next command allows your in import encapsulated
% % postscript files, .epsf or .eps files, which
% % contain vector graphic image data.
% %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
%\usepackage{charter,eulervm}

%\renewcommand{\baselinestretch}{1.5}

\usepackage{amsthm,amsmath,amssymb,upgreek,marvosym,mathtools}
\usepackage{array}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{paralist}
\usepackage{subfig}
\usepackage{tabularx}
\usepackage{tabu}
\usepackage[nottoc]{tocbibind}
\usepackage[usenames,dvipsnames]{color}
\usepackage[pdftex,breaklinks,colorlinks,citecolor={blue}, linkcolor={blue},urlcolor=Maroon]{hyperref}
\usepackage{tkz-graph}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=25mm,
 top=20mm,
 right=25mm,
 }
\usetikzlibrary{automata, positioning,arrows,shapes,decorations.pathmorphing}

 \tikzset{
->, % makes the edges directed
>=stealth, % makes the arrow heads bold
node distance=3cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{reduction}{Reduction}
\newtheorem{proposition}{Proposition}
\newtheorem{scolium}{Scolium}   %% And a not so common one.
\newtheorem{definition}{Definition}
%\newenvironment{proof}{{\sc Proof:}}{~\hfill QED}
\newenvironment{AMS}{}{}
\newenvironment{keywords}{}{}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}
\newcommand{\todo}{(TO BE CONTINUED...)}
\newcommand{\trans}[1]{
	#1^\mathsf{T}
}

\begin{document}
\newpage
\maketitle


% The statement of the problem to be investigated

% An explanation of why the problem is interesting

% A description of what you propose to do,
% Explain the elements that you will have to build
% Explain the elements that you can pick up from open-source sites

% Explain the experiment(s) or performance measurement(s) that you plan to carry out. Two good approaches are
% State the hypothesis that you hope to refute.

% Complete the following sentence: ``The experiments were designed to shed light on the following questions: . . .''

% Then explain what you plan to measure; how you will measure it (if it is not obvious); and where you will obtain test cases.

% List the tasks, broken down into two or three milestones

\section{Motivation}

Program synthesis aims at constructing a program which satisfies all the required specifications, and one common form of specification is the input-output examples. One trivial construction is to utilize the if-then-else statements to capture all input cases and return the corresponding output. However, this trivial approach is not scalable when all given examples conform to some function, since the number of cases captured by the synthesized program will be proportional to the size of the examples, while only one program implementing the function is sufficient. One synthesis approach is to synthesize all possible programs over every subset of the examples, select the minimum number of the synthesized programs that can cover all examples and finally combine the programs using the branching statements. Despite this approach potentially explores exponential many subsets, in practice however, it is efficient in certain circumstances since the input-output examples follow certain distributions. We hence wish to study different underlying distributions of the input-output examples based on which we explain the efficiency of program synthesis in certain circumstances. 


Given a set of $n$ input-output examples, we can construct a graph $G$ as follows: introduce a vertex for each input-output example, and connect two vertices if there exists a program consistent with both examples. If there exists a program consistent on $k$ examples, then their corresponding vertices form a clique of size $k$ in $G$. Note that the edges in the graph may represent distinct programs. The largest number of examples that a program can be consistent on is hence no greater than the size of the maximum clique in the graph $G$. In addition, if the the maximum clique has $O(\log n)$ vertices, then the synthesis program only needs to explore all $O(n)$ subsets of these examples to search for consistent programs. Therefore, we focus on deriving appropriate probablistic graph models for the input-output examples. Then we will compute the expected maximum clique size to provide an explanation of the efficiency of our synthesis algorithm.  

\label{motivation}




\section{Preliminaries}
All graphs discussed in this proposal are undirected and simple. A set of vertices in a graph is a \textit{clique} if there is an edge between each pair of vertices within the set. A clique is \textit{maximal} if it is not properly contained in another clique. A \textit{maximum clique} is a clique with the maximum number of vertices. Note that a graph may have multiple maximum cliques. Given a graph $G$, the size of the maximum clique of $G$ is called the \textit{clique number}, denoted by $\omega(G)$.

\section{Problem definition}

The problem this project attempts to address can be formulated as:

\begin{figure}[h!]
	\centering
	\tikz\path (0,0) node[draw=white, text width=.90\textwidth, rectangle, rounded corners, inner xsep=20pt, inner ysep=2pt]{
		\begin{minipage}[t!]{\textwidth}
			Let $\mathcal{G}$ be a probablistic graph model and a random graph $G$ with $G \sim \mathcal{G}$. Compute $\mathbf{E}[\omega(G)]$.
		\end{minipage}
	};
\end{figure}

Multiple random graph models have already been extensively studied. One classical example is the Erd\H{o}s-R\'enyi model \cite{erdos1960evolution} in which each pair of vertices in a graph with $n$ vertices has equal probability $p$ of being adjacent. When $p = 1/2$, the clique number of $G$ is at most $(2 + \varepsilon)\log_2(n) + 1$ with high probability, for all $\varepsilon > 0$ \cite{danielSpielman}. Power Law graphs characterize the networks in which the number of vertices with a certain degree $k$ is propotional to $1/k^c$ for some constant $c$. This model is studied in \cite{aiello2000random}, but an estimation of the size of the maximum clique is not present in the work. 


\section{Action plan}


We propose to investigate the power law graph model and derive a bound for the size of the maximum cliques in the power law graphs for different parameter $c$. Our intuition is that if there are a set of input-output examples consistent to one program, then examples consistent with any example in the set is likely to be consistent with the same program. If it is an appropriate model for the input-output example setting, our hypothesis is that the maximum clique size of a power graph model on $n$ vertices with parameter $c$ is $O(\log n)$ when $0 < c \leq c_0$ where $c_0$ is some constant, and that in reality $c_0$ should be relatively small. However, this still needs to be supported by proofs and experiments.

In addition to the power law graph model, we plan to find other random graph model for our synthesis setting either based on existing models or constructing a novel one. Hence we propose to research on the existing random graph models with interesting properties\cite{easley2010networks}, and study the input-output examples from real data to build new models.

The goal of this project is to understand different random graph models and evaluate the applicability of each model to the input-output example setting.


\section{Deliverables and milestones}
The milestones for the projects are as follows with deliverables highlighted in \textbf{bold}.
\begin{itemize}
	\item Oct 21: Finish implementing the \textbf{power law graph model}.
	\item Nov 1: Finish reviewing the literature on other models\footnote{A not so measurable milestone, but still critical.}.
	\item Nov 12: Finish implementing and experiments on the \textbf{new model} if possible.
	\item Nov 18: \textbf{Proof sketch} of maximum clique size for power law graph model and new models if applicable.
	\item Dec 2: Finish \textbf{report} write-up and \textbf{slides} preparation.
\end{itemize}



\bibliography{progress}{}
\bibliographystyle{plain}
\end{document}
